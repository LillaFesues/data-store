import { Depth, ISchema, IStore, IStoreTargetItem, NormalizedData, Parent, ValidKey } from '@normalized-db/core';
import { DenormalizerBuilder } from '@normalized-db/denormalizer';
import { NormalizerBuilder } from '@normalized-db/normalizer';
import { Cursor, ObjectStore, Transaction, UpgradeDB } from 'idb';
import { LoggingConfig } from '../../builder/model/logging-config';
import { IDataStore } from '../../data-store-interface';
import { HistoryRange } from '../../model/history-range';
import { LogHistory } from '../../model/log-history';
import { Range } from '../../model/range';
export declare class IndexedDb implements IDataStore {
    protected readonly schema: ISchema;
    protected readonly logging: LoggingConfig;
    private static readonly MODE_READ;
    private static readonly MODE_READ_WRITE;
    private static readonly MODE_VERSION_CHANGE;
    private readonly normalizer;
    private db;
    constructor(schema: ISchema, logging?: LoggingConfig);
    open(name: string, version: number, upgrade?: (UpgradeDB) => void): Promise<void>;
    getLoggingStore(type: string): string;
    createLoggingStore(upgradeDb: UpgradeDB, type: string): void;
    isLoggingActive: boolean;
    getHistory<Key extends ValidKey, T>(type: string, range?: HistoryRange): Promise<LogHistory<Key, T>>;
    clearHistory(type: string, range?: HistoryRange): Promise<void>;
    getTypes(): Promise<string[]>;
    getData(): Promise<NormalizedData>;
    count(type: string): Promise<number>;
    isEmpty(type: string): Promise<boolean>;
    getKeys<Key extends ValidKey>(type: string, range?: Range): Promise<Key[]>;
    getInvertedKeys<Key extends ValidKey>(excludedKeys: Key[], type: string, range?: Range): Promise<Key[]>;
    hasKey<Key extends ValidKey>(key: Key, type: string): Promise<boolean>;
    getAll<T>(type: string, depth?: number | Depth, range?: Range): Promise<T[]>;
    getAllInverted<Key extends ValidKey, T>(excludedKeys: Key[], type: string, depth?: number | Depth, range?: Range): Promise<T[]>;
    getAllByKeys<Key extends ValidKey, T>(keys: Key[], type: string, depth?: number | Depth, range?: Range): Promise<T[]>;
    getByKey<Key extends ValidKey, T>(key: Key, type: string, depth?: number | Depth): Promise<T>;
    getLatestKey<Key extends ValidKey>(type: string): Promise<Key>;
    getOrDefault<Key extends ValidKey, T>(key: Key, type: string, defaultResult?: T, depth?: number | Depth): Promise<T>;
    put<T>(data: T | T[], rootType: string): Promise<void>;
    remove<Key extends ValidKey>(keys: Key | Key[], type: string): Promise<Key[]>;
    getNested<Key extends ValidKey, T>(key: Key, type: string, field: string, depth?: number | Depth): Promise<T>;
    getAllNested<Key extends ValidKey, T>(key: Key, type: string, field: string, depth?: number | Depth, range?: Range): Promise<T[]>;
    getNestedFromArray<Key extends ValidKey, FieldKey extends ValidKey, T>(key: Key, type: string, field: string, fieldKey: FieldKey, depth?: number | Depth): Promise<T>;
    getNestedInverted<Key extends ValidKey, T>(key: Key, type: string, field: string, depth?: number | Depth, range?: Range): Promise<T[]>;
    addNested<Key extends ValidKey, T>(key: Key, type: string, nestedItem: T, field: string): Promise<boolean>;
    removeNested<Key extends ValidKey, T>(key: Key, type: string, nestedItem: T, field: string): Promise<boolean>;
    clear(type?: string): Promise<void>;
    protected buildNormalizer(): NormalizerBuilder;
    protected buildDenormalizer(): DenormalizerBuilder;
    protected read(...storeNames: string[]): Transaction;
    protected write(storeNames: string | string[]): Transaction;
    protected persist(objectStore: ObjectStore, data: any[], type: string): Promise<void>;
    protected persistItem(objectStore: ObjectStore, item: any, key: ValidKey, cursor?: Cursor): Promise<void>;
    protected persistRemoveNested(key: ValidKey, type: string, parent: Parent): Promise<void>;
    protected removeTarget(parent: Parent, keys: ValidKey | ValidKey[], target: IStoreTargetItem): Promise<void>;
    protected iterateRangeCursor(type: string, range: Range, keyOnly?: boolean): Promise<any[]>;
    protected getLastModified(config: IStore, item: any): Date;
    protected notFound(type: string, key: IDBValidKey): void;
    private onUpgradeNeeded(upgradeDb);
    private fetchCallback(keys, type);
    private callPreLog(logEntry);
    private validateType(type);
}
